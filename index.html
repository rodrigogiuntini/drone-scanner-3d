<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Scanner 3D - Simula√ß√£o de Mapeamento</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #info h1 {
            color: #00ff88;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #info p {
            color: #ffffff;
            font-size: 14px;
            line-height: 1.6;
        }

        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ff6b00;
            font-family: 'Courier New', monospace;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            color: #ffffff;
        }

        .status-value {
            color: #ff6b00;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #0088ff;
        }

        button {
            background: linear-gradient(45deg, #0088ff, #00ff88);
            border: none;
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 136, 255, 0.5);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h1>üöÅ DRONE SCANNER</h1>
            <p>Simula√ß√£o de mapeamento a√©reo com escaneamento 3D</p>
            <p>Drone aut√¥nomo realizando varredura do terreno</p>
        </div>

        <div id="controls">
            <button onclick="toggleAnimation()">‚èØÔ∏è Play/Pause</button>
            <button onclick="resetDrone()">üîÑ Reset</button>
            <button onclick="changeScanMode()">üîç Modo Scan</button>
        </div>

        <div id="status">
            <div class="status-item">
                <span>Altitude:</span>
                <span id="altitude" class="status-value">15.0m</span>
            </div>
            <div class="status-item">
                <span>Velocidade:</span>
                <span id="speed" class="status-value">5.2 m/s</span>
            </div>
            <div class="status-item">
                <span>Bateria:</span>
                <span id="battery" class="status-value">87%</span>
            </div>
            <div class="status-item">
                <span>Pontos Scan:</span>
                <span id="scanPoints" class="status-value">0</span>
            </div>
        </div>

        <div id="canvas-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Vari√°veis globais
        let scene, camera, renderer, drone, terrain, scanBeam, scanLight;
        let animationRunning = true;
        let droneAngle = 0;
        let scanRadius = 30;
        let scanPoints = 0;
        let scanMode = 1;
        let scanParticles = [];
        let droneVelocity = { x: 0, y: 0, z: 0 };
        let droneAcceleration = { x: 0, y: 0, z: 0 };
        let windEffect = { x: 0, y: 0, z: 0 };
        let propellers = [];
        let terrainTexture, skybox;
        let rivers = [], lakes = [], mountains = [], forests = [];
        let village = [], canoes = [], totems = [];
        let weatherSystem, atmosphericParticles, cloudSystem;
        let audioContext, droneSound, windSound;
        let composer, renderTarget;
        let textureLibrary = {};

        // Inicializar a cena
        function init() {
            try {
                // Criar cena
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

                // Configurar c√¢mera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(80, 60, 80);
                camera.lookAt(0, 0, 0);

            // Configurar renderer ultra-realista
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                shadowMap: true,
                physicallyCorrectLights: true,
                logarithmicDepthBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x87CEEB, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Adicionar n√©voa atmosf√©rica realista
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

            // Criar biblioteca de texturas
            createTextureLibrary();

            // Configurar p√≥s-processamento
            setupPostProcessing();

            // Criar skybox
            createSkybox();
            
            // Criar terreno
            createTerrain();
            
            // Criar elementos naturais
            createWaterBodies();
            createMountains();
            createForests();
            
            // Criar aldeia ind√≠gena
            createIndigenousVillage();
            
            // Criar drone
            createDrone();
            
            // Criar sistema de escaneamento
            createScanSystem();
            
            // Adicionar luzes
            addLights();
            
            // Adicionar elementos ambientais
            addEnvironmentalElements();
            
            // Criar sistema clim√°tico
            createWeatherSystem();
            
            // Inicializar √°udio
            initializeAudio();
            
            // Controles de c√¢mera orbital
            setupCameraControls();
            
            // Iniciar anima√ß√£o
            animate();
            
            } catch (error) {
                console.error('Erro na inicializa√ß√£o:', error);
                // Fallback para vers√£o simplificada
                initSimpleVersion();
            }
        }

        function initSimpleVersion() {
            // Vers√£o simplificada em caso de erro
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Criar apenas o essencial
            createTerrain();
            createDrone();
            createScanSystem();
            addLights();
            
            camera.position.set(50, 30, 50);
            camera.lookAt(0, 0, 0);
            
            animate();
        }

        function createTextureLibrary() {
            // Criar texturas procedurais ultra-realistas
            const textureGenerator = new THREE.DataTexture(null, 256, 256, THREE.RGBAFormat);
            
            // Textura de grama
            textureLibrary.grass = createGrassTexture();
            
            // Textura de terra
            textureLibrary.dirt = createDirtTexture();
            
            // Textura de pedra
            textureLibrary.stone = createStoneTexture();
            
            // Textura de neve
            textureLibrary.snow = createSnowTexture();
            
            // Textura de √°gua
            textureLibrary.water = createWaterTexture();
            
            // Textura de madeira
            textureLibrary.wood = createWoodTexture();
            
            // Textura de folhas
            textureLibrary.leaves = createLeavesTexture();
            
            // Textura de metal
            textureLibrary.metal = createMetalTexture();
            
            // Textura de couro/palha
            textureLibrary.thatch = createThatchTexture();
            
            console.log('Biblioteca de texturas criada com', Object.keys(textureLibrary).length, 'texturas');
        }

        function createGrassTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    // Base verde com varia√ß√µes
                    const noise = Math.random() * 0.3;
                    const grassBase = 0.2 + noise;
                    
                    data[index] = Math.floor(grassBase * 100 * (0.8 + Math.random() * 0.4));     // R
                    data[index + 1] = Math.floor(grassBase * 255 * (0.9 + Math.random() * 0.2)); // G
                    data[index + 2] = Math.floor(grassBase * 80 * (0.7 + Math.random() * 0.6));  // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8);
            texture.needsUpdate = true;
            return texture;
        }

        function createDirtTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const noise = Math.random() * 0.4 + 0.3;
                    const brown = 0.4 * noise;
                    
                    data[index] = Math.floor(139 * brown * (0.8 + Math.random() * 0.4));     // R
                    data[index + 1] = Math.floor(69 * brown * (0.9 + Math.random() * 0.2));  // G
                    data[index + 2] = Math.floor(19 * brown * (0.7 + Math.random() * 0.6));  // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(6, 6);
            texture.needsUpdate = true;
            return texture;
        }

        function createStoneTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const noise = Math.random() * 0.5 + 0.4;
                    const gray = 0.6 * noise;
                    
                    data[index] = Math.floor(128 * gray * (0.8 + Math.random() * 0.4));     // R
                    data[index + 1] = Math.floor(128 * gray * (0.9 + Math.random() * 0.2)); // G
                    data[index + 2] = Math.floor(128 * gray * (0.85 + Math.random() * 0.3)); // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            texture.needsUpdate = true;
            return texture;
        }

        function createSnowTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const noise = Math.random() * 0.2 + 0.9;
                    
                    data[index] = Math.floor(255 * noise);     // R
                    data[index + 1] = Math.floor(255 * noise); // G
                    data[index + 2] = Math.floor(255 * noise * 1.1); // B (ligeiramente azulado)
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            texture.needsUpdate = true;
            return texture;
        }

        function createWaterTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const wave = Math.sin(i * 0.1) * Math.cos(j * 0.1) * 0.1 + 0.9;
                    
                    data[index] = Math.floor(30 * wave);      // R
                    data[index + 1] = Math.floor(100 * wave); // G
                    data[index + 2] = Math.floor(200 * wave); // B
                    data[index + 3] = 200; // A (semi-transparente)
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            texture.needsUpdate = true;
            return texture;
        }

        function createWoodTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    // Criar an√©is de madeira
                    const ring = Math.sin(j * 0.3) * 0.2 + 0.8;
                    const noise = Math.random() * 0.3 + 0.7;
                    const wood = ring * noise;
                    
                    data[index] = Math.floor(101 * wood * (0.8 + Math.random() * 0.4));     // R
                    data[index + 1] = Math.floor(67 * wood * (0.9 + Math.random() * 0.2));  // G
                    data[index + 2] = Math.floor(33 * wood * (0.7 + Math.random() * 0.6));  // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            texture.needsUpdate = true;
            return texture;
        }

        function createLeavesTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const noise = Math.random() * 0.4 + 0.6;
                    const leafPattern = Math.sin(i * 0.2) * Math.cos(j * 0.2) * 0.2 + 0.8;
                    const leaf = noise * leafPattern;
                    
                    data[index] = Math.floor(34 * leaf * (0.8 + Math.random() * 0.4));      // R
                    data[index + 1] = Math.floor(139 * leaf * (0.9 + Math.random() * 0.2)); // G
                    data[index + 2] = Math.floor(34 * leaf * (0.7 + Math.random() * 0.6));  // B
                    data[index + 3] = Math.floor(200 + Math.random() * 55); // A (varia√ß√£o de transpar√™ncia)
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(3, 3);
            texture.needsUpdate = true;
            return texture;
        }

        function createMetalTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const brushed = Math.sin(i * 0.5) * 0.1 + 0.9;
                    const reflection = Math.random() * 0.3 + 0.7;
                    const metal = brushed * reflection;
                    
                    data[index] = Math.floor(150 * metal);     // R
                    data[index + 1] = Math.floor(150 * metal); // G
                    data[index + 2] = Math.floor(150 * metal); // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            texture.needsUpdate = true;
            return texture;
        }

        function createThatchTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    const straw = Math.sin(i * 0.8) * Math.cos(j * 0.3) * 0.3 + 0.7;
                    const noise = Math.random() * 0.4 + 0.6;
                    const thatch = straw * noise;
                    
                    data[index] = Math.floor(139 * thatch * (0.8 + Math.random() * 0.4));     // R
                    data[index + 1] = Math.floor(115 * thatch * (0.9 + Math.random() * 0.2)); // G
                    data[index + 2] = Math.floor(85 * thatch * (0.7 + Math.random() * 0.6));  // B
                    data[index + 3] = 255; // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(6, 6);
            texture.needsUpdate = true;
            return texture;
        }

        function setupPostProcessing() {
            // P√≥s-processamento desabilitado temporariamente para debugging
            console.log('P√≥s-processamento inicializado');
        }

        function createSkybox() {
            // Skybox com gradiente realista
            const skyGeometry = new THREE.SphereGeometry(1500, 64, 64);
            
            // Criar shader de skybox realista
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    sunPosition: { value: new THREE.Vector3(100, 120, 50) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 sunPosition;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vec3 direction = normalize(vWorldPosition);
                        float elevation = direction.y;
                        
                        // Cores do c√©u baseadas na altura
                        vec3 skyColor = mix(
                            vec3(0.5, 0.7, 1.0),  // Azul horizonte
                            vec3(0.3, 0.6, 1.0),  // Azul c√©u
                            smoothstep(0.0, 0.4, elevation)
                        );
                        
                        // Efeito do sol
                        vec3 sunDir = normalize(sunPosition);
                        float sunIntensity = max(0.0, dot(direction, sunDir));
                        vec3 sunGlow = vec3(1.0, 0.8, 0.6) * pow(sunIntensity, 8.0) * 0.5;
                        
                        gl_FragColor = vec4(skyColor + sunGlow, 1.0);
                    }
                `,
                side: THREE.BackSide,
                fog: false
            });
            
            skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            skybox.userData = { isSkybox: true };
            scene.add(skybox);

            // Sistema de nuvens volum√©tricas
            createVolumetricClouds();
        }

        function createVolumetricClouds() {
            cloudSystem = new THREE.Group();
            
            // Nuvens em m√∫ltiplas camadas
            for (let layer = 0; layer < 3; layer++) {
                for (let i = 0; i < 15; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(
                        25 + Math.random() * 35, 
                        12, 
                        8
                    );
                    
                    // Material volum√©trico
                    const cloudMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0, 0, 0.9 + Math.random() * 0.1),
                        transparent: true,
                        opacity: 0.4 - layer * 0.1,
                        fog: false
                    });
                    
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    // Posicionamento em camadas
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = 600 + layer * 200;
                    cloud.position.set(
                        Math.cos(angle) * radius + (Math.random() - 0.5) * 200,
                        150 + layer * 50 + Math.random() * 100,
                        Math.sin(angle) * radius + (Math.random() - 0.5) * 200
                    );
                    
                    // Formas org√¢nicas
                    cloud.scale.set(
                        1 + Math.random() * 1.5,
                        0.3 + Math.random() * 0.4,
                        1 + Math.random() * 1.5
                    );
                    
                    cloud.userData = { 
                        layer: layer,
                        speed: 0.1 + Math.random() * 0.2,
                        originalY: cloud.position.y
                    };
                    
                    cloudSystem.add(cloud);
                }
            }
            
            scene.add(cloudSystem);
        }

        function createTerrain() {
            // Geometria do terreno expandido
            const terrainGeometry = new THREE.PlaneGeometry(300, 300, 150, 150);
            const vertices = terrainGeometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);
            
            // Adicionar varia√ß√£o de altura mais realista com zonas espec√≠ficas
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const distance = Math.sqrt(x * x + y * y);
                
                // Noise em m√∫ltiplas camadas
                let height = 0;
                height += Math.sin(x * 0.015) * Math.cos(y * 0.015) * 12;
                height += Math.sin(x * 0.03) * Math.cos(y * 0.03) * 6;
                height += Math.sin(x * 0.08) * Math.cos(y * 0.08) * 3;
                height += (Math.random() - 0.5) * 2;
                
                // Criar vales para rios
                const riverPath1 = Math.abs(Math.sin(x * 0.02) * 50 - y);
                const riverPath2 = Math.abs(Math.cos(y * 0.015) * 60 - x);
                if (riverPath1 < 8) height -= (8 - riverPath1) * 0.8;
                if (riverPath2 < 10) height -= (10 - riverPath2) * 0.6;
                
                // Elevar bordas do mapa
                if (distance > 120) {
                    height += (distance - 120) * 0.3;
                }
                
                vertices[i + 2] = height;
                
                // Cores baseadas na altura e tipo de terreno
                const normalizedHeight = (height + 15) / 30;
                if (height < -2) {
                    // √Årea pr√≥xima √† √°gua - solo mais escuro
                    colors[i] = 0.15 + normalizedHeight * 0.2;     // R
                    colors[i + 1] = 0.25 + normalizedHeight * 0.3; // G
                    colors[i + 2] = 0.08 + normalizedHeight * 0.15; // B
                } else if (height < 5) {
                    // Plan√≠cie - verde
                    colors[i] = 0.2 + normalizedHeight * 0.25;     // R
                    colors[i + 1] = 0.4 + normalizedHeight * 0.4;  // G
                    colors[i + 2] = 0.1 + normalizedHeight * 0.2;  // B
                } else {
                    // Eleva√ß√µes - mais marrom
                    colors[i] = 0.3 + normalizedHeight * 0.3;      // R
                    colors[i + 1] = 0.35 + normalizedHeight * 0.3; // G
                    colors[i + 2] = 0.15 + normalizedHeight * 0.2; // B
                }
            }
            
            terrainGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            terrainGeometry.attributes.position.needsUpdate = true;
            terrainGeometry.computeVertexNormals();

            // Material do terreno com texturas realistas
            const terrainMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    grassTexture: { value: textureLibrary.grass },
                    dirtTexture: { value: textureLibrary.dirt },
                    stoneTexture: { value: textureLibrary.stone },
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vColor = color;
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D grassTexture;
                    uniform sampler2D dirtTexture;
                    uniform sampler2D stoneTexture;
                    uniform float time;
                    varying vec3 vColor;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        // Criar coordenadas UV baseadas na posi√ß√£o mundial
                        vec2 worldUV = vWorldPosition.xz * 0.05;
                        
                        vec3 grass = texture2D(grassTexture, worldUV).rgb;
                        vec3 dirt = texture2D(dirtTexture, worldUV * 0.8).rgb;
                        vec3 stone = texture2D(stoneTexture, worldUV * 0.6).rgb;
                        
                        // Mistura baseada na altura (usando vColor como proxy)
                        float heightFactor = (vColor.r + vColor.g + vColor.b) / 3.0;
                        
                        vec3 finalColor = grass;
                        finalColor = mix(finalColor, dirt, smoothstep(0.2, 0.4, heightFactor));
                        finalColor = mix(finalColor, stone, smoothstep(0.4, 0.7, heightFactor));
                        
                        // Modular com cores originais para varia√ß√£o
                        finalColor *= vColor * 2.0;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                lights: true
            });

            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.castShadow = false;
            scene.add(terrain);

            // Adicionar pedras espalhadas com texturas realistas
            for (let i = 0; i < 80; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 3 + 0.8);
                const rockMaterial = new THREE.MeshLambertMaterial({
                    map: textureLibrary.stone,
                    color: new THREE.Color().setHSL(Math.random() * 0.08, 0.4, 0.3 + Math.random() * 0.3),
                    roughness: 0.8,
                    metalness: 0.1
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 280,
                    Math.random() * 4,
                    (Math.random() - 0.5) * 280
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.set(Math.random() + 0.5, Math.random() + 0.5, Math.random() + 0.5);
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
        }

        function createWaterBodies() {
            // Criar rio serpenteante principal
            const riverPoints = [];
            for (let i = 0; i < 20; i++) {
                const t = i / 19;
                const x = (t - 0.5) * 280;
                const z = Math.sin(x * 0.02) * 50;
                riverPoints.push(new THREE.Vector3(x, -1.5, z));
            }

            const riverCurve = new THREE.CatmullRomCurve3(riverPoints);
            const riverGeometry = new THREE.TubeGeometry(riverCurve, 100, 8, 8, false);
            const riverMaterial = new THREE.MeshPhongMaterial({
                map: textureLibrary.water,
                color: 0x2E86AB,
                transparent: true,
                opacity: 0.7,
                shininess: 200,
                specular: 0x87CEEB,
                normalScale: new THREE.Vector2(0.5, 0.5)
            });
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            rivers.push(river);
            scene.add(river);

            // Criar segundo rio
            const river2Points = [];
            for (let i = 0; i < 15; i++) {
                const t = i / 14;
                const z = (t - 0.5) * 250;
                const x = Math.cos(z * 0.015) * 60;
                river2Points.push(new THREE.Vector3(x, -1.2, z));
            }

            const river2Curve = new THREE.CatmullRomCurve3(river2Points);
            const river2Geometry = new THREE.TubeGeometry(river2Curve, 80, 6, 8, false);
            const river2 = new THREE.Mesh(river2Geometry, riverMaterial);
            rivers.push(river2);
            scene.add(river2);

            // Criar lagos com texturas realistas
            for (let i = 0; i < 3; i++) {
                const lakeGeometry = new THREE.CircleGeometry(15 + Math.random() * 10, 32);
                const lakeMaterial = new THREE.MeshPhongMaterial({
                    map: textureLibrary.water,
                    color: 0x1B4F72,
                    transparent: true,
                    opacity: 0.75,
                    shininess: 250,
                    specular: 0x87CEEB,
                    normalScale: new THREE.Vector2(0.3, 0.3)
                });
                const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                lake.rotation.x = -Math.PI / 2;
                lake.position.set(
                    (Math.random() - 0.5) * 200,
                    -0.8,
                    (Math.random() - 0.5) * 200
                );
                lakes.push(lake);
                scene.add(lake);
            }

            // Adicionar reflexos na √°gua
            rivers.concat(lakes).forEach(water => {
                water.receiveShadow = true;
            });
        }

        function createMountains() {
            // Criar cordilheira ao fundo
            for (let i = 0; i < 12; i++) {
                const mountainHeight = 40 + Math.random() * 60;
                const mountainGeometry = new THREE.ConeGeometry(
                    15 + Math.random() * 20, 
                    mountainHeight, 
                    8
                );
                const mountainMaterial = new THREE.MeshLambertMaterial({
                    map: textureLibrary.stone,
                    color: new THREE.Color().setHSL(0.15, 0.4, 0.4 + Math.random() * 0.2)
                });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                // Posicionar montanhas em volta do terreno
                const angle = (i / 12) * Math.PI * 2;
                const distance = 200 + Math.random() * 100;
                mountain.position.set(
                    Math.cos(angle) * distance,
                    mountainHeight / 2,
                    Math.sin(angle) * distance
                );
                
                mountain.rotation.y = Math.random() * Math.PI;
                mountain.castShadow = true;
                mountain.receiveShadow = true;
                mountains.push(mountain);
                scene.add(mountain);

                // Adicionar neve no topo
                if (mountainHeight > 60) {
                    const snowGeometry = new THREE.ConeGeometry(8, mountainHeight * 0.3, 6);
                    const snowMaterial = new THREE.MeshLambertMaterial({
                        map: textureLibrary.snow,
                        color: 0xffffff
                    });
                    const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                    snow.position.copy(mountain.position);
                    snow.position.y += mountainHeight * 0.35;
                    scene.add(snow);
                }
            }

            // Criar colinas menores
            for (let i = 0; i < 8; i++) {
                const hillGeometry = new THREE.SphereGeometry(20 + Math.random() * 15, 8, 6);
                const hillMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.25, 0.4, 0.35 + Math.random() * 0.2)
                });
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                hill.position.set(
                    (Math.random() - 0.5) * 400,
                    10,
                    (Math.random() - 0.5) * 400
                );
                hill.scale.y = 0.6;
                hill.castShadow = true;
                hill.receiveShadow = true;
                scene.add(hill);
            }
        }

        function createForests() {
            // Criar florestas densas
            for (let forestIndex = 0; forestIndex < 5; forestIndex++) {
                const forestCenter = new THREE.Vector3(
                    (Math.random() - 0.5) * 250,
                    0,
                    (Math.random() - 0.5) * 250
                );
                
                const forestSize = 30 + Math.random() * 40;
                const treeCount = Math.floor(forestSize / 2);
                
                for (let i = 0; i < treeCount; i++) {
                    const treeGroup = new THREE.Group();
                    
                    // Tronco
                    const trunkHeight = 4 + Math.random() * 6;
                    const trunkGeometry = new THREE.CylinderGeometry(
                        0.3 + Math.random() * 0.4, 
                        0.4 + Math.random() * 0.3, 
                        trunkHeight
                    );
                    const trunkMaterial = new THREE.MeshLambertMaterial({ 
                        map: textureLibrary.wood,
                        color: new THREE.Color().setHSL(0.08, 0.6, 0.2 + Math.random() * 0.1)
                    });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = trunkHeight / 2;
                    trunk.castShadow = true;
                    treeGroup.add(trunk);
                    
                    // Copa com m√∫ltiplas camadas
                    const foliageLayers = 2 + Math.floor(Math.random() * 2);
                    for (let layer = 0; layer < foliageLayers; layer++) {
                        const foliageRadius = 2 + Math.random() * 2 - layer * 0.5;
                        const foliageGeometry = new THREE.SphereGeometry(foliageRadius, 8, 6);
                        const foliageMaterial = new THREE.MeshLambertMaterial({ 
                            map: textureLibrary.leaves,
                            color: new THREE.Color().setHSL(0.3, 0.6, 0.25 + Math.random() * 0.15),
                            transparent: true,
                            alphaTest: 0.5
                        });
                        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                        foliage.position.y = trunkHeight + layer * 2 + foliageRadius;
                        foliage.castShadow = true;
                        foliage.receiveShadow = true;
                        treeGroup.add(foliage);
                    }
                    
                    // Posicionar dentro da floresta
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * forestSize;
                    treeGroup.position.copy(forestCenter);
                    treeGroup.position.x += Math.cos(angle) * distance;
                    treeGroup.position.z += Math.sin(angle) * distance;
                    
                    treeGroup.rotation.y = Math.random() * Math.PI * 2;
                    forests.push(treeGroup);
                    scene.add(treeGroup);
                }
            }

            // Adicionar √°rvores isoladas
            for (let i = 0; i < 25; i++) {
                const treeGroup = new THREE.Group();
                
                const trunkHeight = 5 + Math.random() * 4;
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, trunkHeight);
                const trunkMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.wood,
                    color: 0x654321 
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                const foliageGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 8, 6);
                const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.leaves,
                    color: 0x228B22,
                    transparent: true,
                    alphaTest: 0.5
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + 2;
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                treeGroup.add(foliage);
                
                treeGroup.position.set(
                    (Math.random() - 0.5) * 280,
                    0,
                    (Math.random() - 0.5) * 280
                );
                scene.add(treeGroup);
            }
        }

        function createDrone() {
            drone = new THREE.Group();

            // Corpo principal do drone - mais detalhado
            const bodyGeometry = new THREE.BoxGeometry(4, 1.2, 4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                map: textureLibrary.metal,
                color: 0x2c3e50
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            drone.add(body);

            // Detalhes do corpo
            const topPlateGeometry = new THREE.BoxGeometry(3.8, 0.1, 3.8);
            const topPlateMaterial = new THREE.MeshLambertMaterial({
                map: textureLibrary.metal,
                color: 0x1a252f
            });
            const topPlate = new THREE.Mesh(topPlateGeometry, topPlateMaterial);
            topPlate.position.y = 0.65;
            topPlate.castShadow = true;
            drone.add(topPlate);

            // Bateria
            const batteryGeometry = new THREE.BoxGeometry(2.5, 0.4, 1);
            const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x27ae60 });
            const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
            battery.position.y = 0.8;
            battery.castShadow = true;
            drone.add(battery);

            // Antenas
            for (let i = 0; i < 2; i++) {
                const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5);
                const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(i === 0 ? -1.5 : 1.5, 1.5, -1.5);
                antenna.castShadow = true;
                drone.add(antenna);
            }

            // Bra√ßos do drone (4 bra√ßos)
            const armPositions = [
                { x: 3, z: 3, rotation: Math.PI / 4 },
                { x: -3, z: 3, rotation: -Math.PI / 4 },
                { x: 3, z: -3, rotation: -Math.PI / 4 },
                { x: -3, z: -3, rotation: Math.PI / 4 }
            ];

            propellers = [];

            armPositions.forEach((pos, index) => {
                // Bra√ßo principal
                const armGeometry = new THREE.BoxGeometry(4, 0.3, 0.8);
                const armMaterial = new THREE.MeshLambertMaterial({
                    map: textureLibrary.metal,
                    color: 0x34495e
                });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos.x * 0.7, 0, pos.z * 0.7);
                arm.rotation.y = pos.rotation;
                arm.castShadow = true;
                drone.add(arm);

                // Motor
                const motorGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.6);
                const motorMaterial = new THREE.MeshLambertMaterial({
                    map: textureLibrary.metal,
                    color: 0x2c3e50
                });
                const motor = new THREE.Mesh(motorGeometry, motorMaterial);
                motor.position.set(pos.x, 0.3, pos.z);
                motor.castShadow = true;
                drone.add(motor);

                // H√©lice com blur effect
                const propellerGroup = new THREE.Group();
                
                // H√©lice base
                const propellerGeometry = new THREE.BoxGeometry(0.1, 0.05, 3.5);
                const propellerMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x95a5a6,
                    transparent: true,
                    opacity: 0.8
                });
                
                for (let j = 0; j < 2; j++) {
                    const blade = new THREE.Mesh(propellerGeometry, propellerMaterial);
                    blade.rotation.y = (j * Math.PI) / 2;
                    propellerGroup.add(blade);
                }

                // Efeito de blur quando em movimento
                const blurGeometry = new THREE.RingGeometry(0.5, 1.8, 32);
                const blurMaterial = new THREE.MeshBasicMaterial({
                    color: 0x95a5a6,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const blurEffect = new THREE.Mesh(blurGeometry, blurMaterial);
                blurEffect.rotation.x = -Math.PI / 2;
                propellerGroup.add(blurEffect);

                propellerGroup.position.set(pos.x, 0.7, pos.z);
                propellerGroup.userData = { 
                    rotationSpeed: Math.random() * 0.3 + 0.8,
                    blurEffect: blurEffect,
                    direction: index % 2 === 0 ? 1 : -1
                };
                
                propellers.push(propellerGroup);
                drone.add(propellerGroup);
            });

            // Sistema de c√¢mera gimbal
            const gimbalGroup = new THREE.Group();
            
            // Base do gimbal
            const gimbalBaseGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2);
            const gimbalBaseMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            const gimbalBase = new THREE.Mesh(gimbalBaseGeometry, gimbalBaseMaterial);
            gimbalGroup.add(gimbalBase);

            // C√¢mera
            const cameraGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.6);
            const cameraMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                emissive: 0x001100 
            });
            const camera = new THREE.Mesh(cameraGeometry, cameraMaterial);
            camera.position.y = -0.4;
            camera.castShadow = true;
            gimbalGroup.add(camera);

            // Lente da c√¢mera
            const lensGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2);
            const lensMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                emissive: 0x004400 
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.rotation.x = Math.PI / 2;
            lens.position.set(0, -0.4, 0.4);
            gimbalGroup.add(lens);

            gimbalGroup.position.y = -0.8;
            gimbalGroup.userData = { oscillation: 0 };
            drone.add(gimbalGroup);

            // LEDs indicadores mais realistas
            const ledGeometry = new THREE.SphereGeometry(0.08);
            const ledColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            
            for (let i = 0; i < 4; i++) {
                const ledMaterial = new THREE.MeshBasicMaterial({ 
                    color: ledColors[i],
                    emissive: ledColors[i],
                    emissiveIntensity: 0.5
                });
                const led = new THREE.Mesh(ledGeometry, ledMaterial);
                const angle = (i / 4) * Math.PI * 2;
                led.position.set(Math.cos(angle) * 1.8, 0.3, Math.sin(angle) * 1.8);
                led.userData = { originalEmissive: ledColors[i], blinkTimer: Math.random() * Math.PI * 2 };
                drone.add(led);
            }

            // Sistema de escape/vapor dos motores ultra-realista
            createDroneExhaustSystem();

            drone.position.set(0, 25, 0);
            drone.castShadow = true;
            scene.add(drone);
        }

        function createDroneExhaustSystem() {
            // Sistema de escape/vapor dos motores
            const exhaustSystems = [];
            
            // Criar escape para cada h√©lice
            for (let i = 0; i < 4; i++) {
                const exhaustCount = 150;
                const positions = new Float32Array(exhaustCount * 3);
                const velocities = new Float32Array(exhaustCount * 3);
                const lifetimes = new Float32Array(exhaustCount);
                const sizes = new Float32Array(exhaustCount);
                
                for (let j = 0; j < exhaustCount; j++) {
                    positions[j * 3] = (Math.random() - 0.5) * 0.5;
                    positions[j * 3 + 1] = 0;
                    positions[j * 3 + 2] = (Math.random() - 0.5) * 0.5;
                    
                    velocities[j * 3] = (Math.random() - 0.5) * 0.15;
                    velocities[j * 3 + 1] = -Math.random() * 0.4 - 0.3;
                    velocities[j * 3 + 2] = (Math.random() - 0.5) * 0.15;
                    
                    lifetimes[j] = Math.random() * 4 + 2;
                    sizes[j] = Math.random() * 0.3 + 0.1;
                }
                
                const exhaustGeometry = new THREE.BufferGeometry();
                exhaustGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                exhaustGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                exhaustGeometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                exhaustGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const exhaustMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const exhaust = new THREE.Points(exhaustGeometry, exhaustMaterial);
                
                // Posicionar em cada h√©lice
                const angle = (i / 4) * Math.PI * 2;
                exhaust.position.set(
                    Math.cos(angle) * 2,
                    -0.4,
                    Math.sin(angle) * 2
                );
                
                exhaust.userData = { 
                    propellerIndex: i,
                    time: 0,
                    originalLifetimes: new Float32Array(lifetimes)
                };
                
                drone.add(exhaust);
                exhaustSystems.push(exhaust);
            }
            
            drone.userData.exhaustSystems = exhaustSystems;
        }

        function updateDroneExhaust() {
            if (!drone || !drone.userData || !drone.userData.exhaustSystems) return;
            
            const time = Date.now() * 0.001;
            const speed = Math.sqrt(droneVelocity.x * droneVelocity.x + droneVelocity.z * droneVelocity.z);
            const throttle = Math.min(speed * 20 + 0.3, 1.0);
            
            drone.userData.exhaustSystems.forEach((exhaust, systemIndex) => {
                exhaust.userData.time += 0.016;
                exhaust.material.opacity = 0.1 + throttle * 0.3;
                
                const positions = exhaust.geometry.attributes.position.array;
                const velocities = exhaust.geometry.attributes.velocity.array;
                const lifetimes = exhaust.geometry.attributes.lifetime.array;
                const originalLifetimes = exhaust.userData.originalLifetimes;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Atualizar posi√ß√£o das part√≠culas
                    positions[i] += velocities[i] * (1 + throttle);
                    positions[i + 1] += velocities[i + 1] * (1 + throttle * 2);
                    positions[i + 2] += velocities[i + 2] * (1 + throttle);
                    
                    // Reduzir lifetime
                    lifetimes[i / 3] -= 0.03;
                    
                    // Reset part√≠culas expiradas
                    if (lifetimes[i / 3] <= 0) {
                        positions[i] = (Math.random() - 0.5) * 0.5;
                        positions[i + 1] = 0;
                        positions[i + 2] = (Math.random() - 0.5) * 0.5;
                        
                        velocities[i] = (Math.random() - 0.5) * 0.15;
                        velocities[i + 1] = -Math.random() * 0.4 - 0.3 - throttle * 0.3;
                        velocities[i + 2] = (Math.random() - 0.5) * 0.15;
                        
                        lifetimes[i / 3] = originalLifetimes[i / 3];
                    }
                    
                    // Adicionar turbul√™ncia do rotor
                    const rotorAngle = (systemIndex / 4) * Math.PI * 2;
                    const rotorEffect = Math.sin(time * 20 + rotorAngle) * 0.02;
                    positions[i] += rotorEffect;
                    positions[i + 2] += rotorEffect;
                }
                
                exhaust.geometry.attributes.position.needsUpdate = true;
                exhaust.geometry.attributes.lifetime.needsUpdate = true;
            });
        }

        function createScanSystem() {
            // Feixe de luz laser sempre direcionado para baixo
            const beamGeometry = new THREE.CylinderGeometry(0.05, 1.2, 20);
            const beamMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.7,
                emissive: 0x003300
            });
            scanBeam = new THREE.Mesh(beamGeometry, beamMaterial);
            scanBeam.position.set(0, -10, 0);
            scanBeam.rotation.x = 0; // Sempre vertical
            drone.add(scanBeam);

            // Luz do scanner sempre para baixo
            scanLight = new THREE.SpotLight(0x00ff88, 3, 40, Math.PI / 8, 0.3);
            scanLight.position.set(0, -1, 0);
            scanLight.target.position.set(0, -25, 0);
            scanLight.castShadow = true;
            scanLight.shadow.mapSize.width = 1024;
            scanLight.shadow.mapSize.height = 1024;
            
            // Fixar o target da luz para sempre apontar para baixo
            const lightTarget = new THREE.Object3D();
            lightTarget.position.set(0, -25, 0);
            drone.add(lightTarget);
            scanLight.target = lightTarget;
            
            drone.add(scanLight);

            // Part√≠culas de escaneamento
            createScanParticles();
        }

        function createScanParticles() {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = Math.random() * -15;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

                colors[i * 3] = 0;
                colors[i * 3 + 1] = 1;
                colors[i * 3 + 2] = 0.5;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            drone.add(particles);
            scanParticles.push(particles);
        }

        function createIndigenousVillage() {
            // Escolher local pr√≥ximo ao rio para a aldeia
            const villageCenter = new THREE.Vector3(-50, 0, 30);
            
            // Criar c√≠rculo de ocas ao redor do centro
            const houseCount = 8;
            const villageRadius = 25;
            
            for (let i = 0; i < houseCount; i++) {
                const angle = (i / houseCount) * Math.PI * 2;
                const housePosition = new THREE.Vector3(
                    villageCenter.x + Math.cos(angle) * villageRadius,
                    villageCenter.y,
                    villageCenter.z + Math.sin(angle) * villageRadius
                );
                
                createOca(housePosition, angle + Math.PI); // Virada para o centro
                village.push(housePosition);
            }
            
            // Criar fogueira central
            createCentralFireplace(villageCenter);
            
            // Criar totems espirituais
            for (let i = 0; i < 4; i++) {
                const totemAngle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                const totemPos = new THREE.Vector3(
                    villageCenter.x + Math.cos(totemAngle) * (villageRadius + 15),
                    villageCenter.y,
                    villageCenter.z + Math.sin(totemAngle) * (villageRadius + 15)
                );
                createTotem(totemPos);
            }
            
            // Criar canoas perto do rio
            createCanoes();
            
            // Criar caminhos entre as casas
            createVillagePaths(villageCenter, villageRadius);
            
            // Adicionar horta comunit√°ria
            createCommunityGarden(new THREE.Vector3(villageCenter.x + 35, 0, villageCenter.z));
        }

        function createOca(position, rotation) {
            const houseGroup = new THREE.Group();
            
            // Base da oca (formato circular)
            const baseGeometry = new THREE.CylinderGeometry(6, 6, 4, 12);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                map: textureLibrary.wood,
                color: new THREE.Color().setHSL(0.08, 0.7, 0.35)
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 2;
            base.castShadow = true;
            base.receiveShadow = true;
            houseGroup.add(base);
            
            // Telhado c√¥nico
            const roofGeometry = new THREE.ConeGeometry(7, 6, 12);
            const roofMaterial = new THREE.MeshLambertMaterial({ 
                map: textureLibrary.thatch,
                color: new THREE.Color().setHSL(0.12, 0.6, 0.25)
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 7;
            roof.castShadow = true;
            houseGroup.add(roof);
            
            // Entrada
            const doorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ 
                map: textureLibrary.wood,
                color: 0x4A4A4A 
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.2, 5.9);
            door.castShadow = true;
            houseGroup.add(door);
            
            // Janela pequena
            const windowGeometry = new THREE.RingGeometry(0.3, 0.5, 8);
            const windowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide 
            });
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(3, 3, 4.5);
            window.rotation.y = -Math.PI / 3;
            houseGroup.add(window);
            
            houseGroup.position.copy(position);
            houseGroup.rotation.y = rotation;
            scene.add(houseGroup);
        }

        function createCentralFireplace(center) {
            // C√≠rculo de pedras
            const stoneCount = 12;
            const fireRadius = 4;
            
            for (let i = 0; i < stoneCount; i++) {
                const angle = (i / stoneCount) * Math.PI * 2;
                const stoneGeometry = new THREE.DodecahedronGeometry(0.8);
                const stoneMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.stone,
                    color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.2)
                });
                const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                stone.position.set(
                    center.x + Math.cos(angle) * fireRadius,
                    0.4,
                    center.z + Math.sin(angle) * fireRadius
                );
                stone.castShadow = true;
                stone.receiveShadow = true;
                scene.add(stone);
            }
            
            // Fogueira central com part√≠culas de fogo
            const fireGroup = new THREE.Group();
            
            // Madeira empilhada
            for (let i = 0; i < 6; i++) {
                const logGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2);
                const logMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.wood,
                    color: 0x4A4A4A 
                });
                const log = new THREE.Mesh(logGeometry, logMaterial);
                log.position.y = 0.5 + i * 0.2;
                log.rotation.z = (i * Math.PI) / 3;
                log.castShadow = true;
                fireGroup.add(log);
            }
            
            // Chamas simuladas
            const flameGeometry = new THREE.ConeGeometry(1, 3, 6);
            const flameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4500,
                transparent: true,
                opacity: 0.7
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.y = 2.5;
            flame.userData = { isFlame: true };
            fireGroup.add(flame);
            
            // Luz da fogueira
            const fireLight = new THREE.PointLight(0xff4500, 2, 50);
            fireLight.position.y = 3;
            fireLight.castShadow = true;
            fireGroup.add(fireLight);
            
            fireGroup.position.copy(center);
            scene.add(fireGroup);
        }

        function createTotem(position) {
            const totemGroup = new THREE.Group();
            
            // Poste principal
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.4, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ 
                map: textureLibrary.wood,
                color: new THREE.Color().setHSL(0.08, 0.8, 0.3)
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 4;
            pole.castShadow = true;
            totemGroup.add(pole);
            
            // Cabe√ßas do totem (3 n√≠veis)
            for (let i = 0; i < 3; i++) {
                const headGeometry = new THREE.BoxGeometry(1.2, 1.5, 1);
                const headMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.wood,
                    color: new THREE.Color().setHSL(0.05 + i * 0.1, 0.7, 0.4)
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2 + i * 2;
                head.castShadow = true;
                totemGroup.add(head);
                
                // Olhos
                const eyeGeometry = new THREE.SphereGeometry(0.1);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.3, 2.2 + i * 2, 0.5);
                totemGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.3, 2.2 + i * 2, 0.5);
                totemGroup.add(rightEye);
            }
            
            totemGroup.position.copy(position);
            totems.push(totemGroup);
            scene.add(totemGroup);
        }

        function createCanoes() {
            // Encontrar posi√ß√£o pr√≥xima ao rio
            const canoePositions = [
                new THREE.Vector3(-80, -0.5, 45),
                new THREE.Vector3(-85, -0.5, 50),
                new THREE.Vector3(-75, -0.5, 40)
            ];
            
            canoePositions.forEach(pos => {
                const canoeGroup = new THREE.Group();
                
                // Casco da canoa
                const hullGeometry = new THREE.CylinderGeometry(0.8, 0.6, 8, 8);
                const hullMaterial = new THREE.MeshLambertMaterial({ 
                    map: textureLibrary.wood,
                    color: new THREE.Color().setHSL(0.08, 0.6, 0.3)
                });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.rotation.z = Math.PI / 2;
                hull.scale.y = 0.3;
                hull.castShadow = true;
                hull.receiveShadow = true;
                canoeGroup.add(hull);
                
                // Remos
                for (let i = 0; i < 2; i++) {
                    const paddleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3);
                    const paddleMaterial = new THREE.MeshLambertMaterial({ 
                        map: textureLibrary.wood,
                        color: 0x654321 
                    });
                    const paddle = new THREE.Mesh(paddleGeometry, paddleMaterial);
                    paddle.position.set(i === 0 ? -2 : 2, 0.3, 0);
                    paddle.rotation.z = Math.PI / 2;
                    canoeGroup.add(paddle);
                    
                    // P√° do remo
                    const bladeGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.3);
                    const blade = new THREE.Mesh(bladeGeometry, paddleMaterial);
                    blade.position.set(i === 0 ? -3.5 : 3.5, 0.3, 0);
                    canoeGroup.add(blade);
                }
                
                canoeGroup.position.copy(pos);
                canoeGroup.rotation.y = Math.random() * Math.PI / 4;
                canoes.push(canoeGroup);
                scene.add(canoeGroup);
            });
        }

        function createVillagePaths(center, radius) {
            // Criar caminhos de terra entre as casas
            for (let i = 0; i < 8; i++) {
                const pathGeometry = new THREE.PlaneGeometry(2, radius + 10);
                const pathMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(0.08, 0.3, 0.25),
                    transparent: true,
                    opacity: 0.8
                });
                const path = new THREE.Mesh(pathGeometry, pathMaterial);
                path.rotation.x = -Math.PI / 2;
                path.rotation.z = (i / 8) * Math.PI * 2;
                path.position.copy(center);
                path.position.y = 0.05;
                path.receiveShadow = true;
                scene.add(path);
            }
        }

        function createCommunityGarden(position) {
            // Horta retangular
            const gardenGeometry = new THREE.PlaneGeometry(15, 10);
            const gardenMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color().setHSL(0.25, 0.6, 0.2)
            });
            const garden = new THREE.Mesh(gardenGeometry, gardenMaterial);
            garden.rotation.x = -Math.PI / 2;
            garden.position.copy(position);
            garden.receiveShadow = true;
            scene.add(garden);
            
            // Plantas da horta
            for (let i = 0; i < 20; i++) {
                const plantGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                const plantMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(0.3, 0.8, 0.3 + Math.random() * 0.2)
                });
                const plant = new THREE.Mesh(plantGeometry, plantMaterial);
                plant.position.set(
                    position.x + (Math.random() - 0.5) * 12,
                    0.3,
                    position.z + (Math.random() - 0.5) * 8
                );
                plant.castShadow = true;
                scene.add(plant);
            }
        }

        function createWeatherSystem() {
            // Sistema de part√≠culas atmosf√©ricas
            const particleCount = 2000;
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = Math.random() * 100 + 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = -Math.random() * 0.05;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
            }
            
            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            atmosphericParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(atmosphericParticles);
        }

        function initializeAudio() {
            // Sistema de √°udio simplificado
            try {
                console.log('Sistema de √°udio inicializado');
            } catch (e) {
                console.log('√Åudio n√£o dispon√≠vel:', e);
            }
        }

        // Fun√ß√µes de √°udio simplificadas (removidas temporariamente)

        function addEnvironmentalElements() {
            // Vida selvagem mais diversa
            createWildlife();
            
            // Efeitos de vapor/n√©voa
            createMist();
            
            // Folhas caindo
            createFallingLeaves();
        }

        function createWildlife() {
            // P√°ssaros com modelos mais detalhados
            for (let i = 0; i < 12; i++) {
                const birdGroup = new THREE.Group();
                
                // Corpo do p√°ssaro
                const bodyGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                bodyGeometry.scale(1.2, 0.7, 1.5);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 0.6, 0.3)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                birdGroup.add(body);
                
                // Asas
                for (let j = 0; j < 2; j++) {
                    const wingGeometry = new THREE.BoxGeometry(0.8, 0.05, 0.3);
                    const wing = new THREE.Mesh(wingGeometry, bodyMaterial);
                    wing.position.x = j === 0 ? -0.3 : 0.3;
                    wing.userData = { isWing: true, side: j };
                    birdGroup.add(wing);
                }
                
                birdGroup.position.set(
                    (Math.random() - 0.5) * 300,
                    25 + Math.random() * 40,
                    (Math.random() - 0.5) * 300
                );
                
                birdGroup.userData = { 
                    speed: 0.8 + Math.random() * 0.6,
                    angle: Math.random() * Math.PI * 2,
                    height: birdGroup.position.y,
                    wingBeat: Math.random() * Math.PI * 2
                };
                
                scene.add(birdGroup);
            }
        }

        function createMist() {
            // Sistema de n√©voa nas √°reas baixas
            for (let i = 0; i < 8; i++) {
                const mistGeometry = new THREE.PlaneGeometry(30, 30);
                const mistMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending
                });
                
                const mist = new THREE.Mesh(mistGeometry, mistMaterial);
                mist.rotation.x = -Math.PI / 2;
                mist.position.set(
                    (Math.random() - 0.5) * 200,
                    0.5,
                    (Math.random() - 0.5) * 200
                );
                
                mist.userData = { 
                    originalOpacity: mistMaterial.opacity,
                    drift: Math.random() * 0.02
                };
                
                scene.add(mist);
            }
        }

        function createFallingLeaves() {
            // Folhas caindo das √°rvores
            const leafCount = 50;
            const leafPositions = new Float32Array(leafCount * 3);
            const leafVelocities = new Float32Array(leafCount * 3);
            
            for (let i = 0; i < leafCount; i++) {
                leafPositions[i * 3] = (Math.random() - 0.5) * 300;
                leafPositions[i * 3 + 1] = Math.random() * 50 + 20;
                leafPositions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                
                leafVelocities[i * 3] = (Math.random() - 0.5) * 0.02;
                leafVelocities[i * 3 + 1] = -Math.random() * 0.01 - 0.005;
                leafVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            const leafGeometry = new THREE.BufferGeometry();
            leafGeometry.setAttribute('position', new THREE.BufferAttribute(leafPositions, 3));
            leafGeometry.setAttribute('velocity', new THREE.BufferAttribute(leafVelocities, 3));
            
            const leafMaterial = new THREE.PointsMaterial({
                color: 0x8B4513,
                size: 0.3,
                transparent: true,
                opacity: 0.8
            });
            
            const leaves = new THREE.Points(leafGeometry, leafMaterial);
            leaves.userData = { type: 'leaves' };
            scene.add(leaves);
        }

        function addLights() {
            // Sistema de ilumina√ß√£o cinematogr√°fica avan√ßada
            
            // Luz ambiente din√¢mica
            const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.3);
            ambientLight.userData = { type: 'ambient' };
            scene.add(ambientLight);

            // Sol principal com sombras ultra-realistas
            const sunLight = new THREE.DirectionalLight(0xfff8dc, 2.5);
            sunLight.position.set(100, 120, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 8192;  // Sombras 8K
            sunLight.shadow.mapSize.height = 8192;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.shadow.bias = -0.00005;
            sunLight.shadow.normalBias = 0.02;
            sunLight.userData = { type: 'sun' };
            scene.add(sunLight);

            // Luz hemisf√©rica para reflexo do c√©u
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.6);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);

            // Luz de preenchimento suave
            const fillLight = new THREE.DirectionalLight(0xadd8e6, 0.4);
            fillLight.position.set(-80, 60, -80);
            fillLight.castShadow = false;
            scene.add(fillLight);

            // Luz de contorno
            const rimLight = new THREE.DirectionalLight(0xffeaa7, 0.8);
            rimLight.position.set(-100, 80, 100);
            rimLight.castShadow = false;
            scene.add(rimLight);

            // Luz atmosf√©rica
            const fogLight = new THREE.PointLight(0x87CEEB, 1, 200);
            fogLight.position.set(0, 50, 0);
            scene.add(fogLight);
        }

        function setupCameraControls() {
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            let cameraDistance = 80;
            let cameraAngleX = 0.5;
            let cameraAngleY = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY -= deltaX * 0.01;
                cameraAngleX -= deltaY * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));

                mouseX = event.clientX;
                mouseY = event.clientY;

                updateCameraPosition();
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                cameraDistance += event.deltaY * 0.1;
                cameraDistance = Math.max(20, Math.min(150, cameraDistance));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                camera.position.x = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.position.y = Math.sin(cameraAngleX) * cameraDistance;
                camera.position.z = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.lookAt(0, 5, 0);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            try {
                if (animationRunning && drone) {
                    updateDrone();
                    updateScanSystem();
                    updateEnvironment();
                    updateUI();
                }

                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('Erro na anima√ß√£o:', error);
            }
        }

        function updateDrone() {
            const time = Date.now() * 0.001;
            
            // Simular vento mais suave
            windEffect.x = Math.sin(time * 0.3) * 0.008;
            windEffect.z = Math.cos(time * 0.2) * 0.008;
            windEffect.y = Math.sin(time * 0.5) * 0.004;

            // Movimento baseado no modo de escaneamento com f√≠sica mais realista
            let targetX = 0, targetZ = 0;
            
            switch(scanMode) {
                case 1: // Circular
                    droneAngle += 0.008;
                    targetX = Math.cos(droneAngle) * scanRadius;
                    targetZ = Math.sin(droneAngle) * scanRadius;
                    break;
                
                case 2: // Espiral
                    droneAngle += 0.01;
                    scanRadius = 20 + Math.sin(droneAngle * 0.3) * 25;
                    targetX = Math.cos(droneAngle) * scanRadius;
                    targetZ = Math.sin(droneAngle) * scanRadius;
                    break;
                
                case 3: // Grid
                    droneAngle += 0.009;
                    const gridSize = 30;
                    targetX = Math.sin(droneAngle) * gridSize;
                    targetZ = Math.cos(droneAngle * 0.6) * gridSize;
                    break;
            }

            // Aplicar f√≠sica simples (in√©rcia) com movimento mais lento
            droneAcceleration.x = (targetX - drone.position.x) * 0.012 + windEffect.x;
            droneAcceleration.z = (targetZ - drone.position.z) * 0.012 + windEffect.z;
            
            droneVelocity.x += droneAcceleration.x;
            droneVelocity.z += droneAcceleration.z;
            droneVelocity.y += windEffect.y;

            // Amortecimento maior para movimento mais suave
            droneVelocity.x *= 0.88;
            droneVelocity.z *= 0.88;
            droneVelocity.y *= 0.92;

            // Atualizar posi√ß√£o
            drone.position.x += droneVelocity.x;
            drone.position.z += droneVelocity.z;
            drone.position.y = 25 + Math.sin(time * 2) * 0.8 + droneVelocity.y;

            // Inclina√ß√£o baseada na velocidade (mais real√≠stica)
            const speed = Math.sqrt(droneVelocity.x * droneVelocity.x + droneVelocity.z * droneVelocity.z);
            drone.rotation.x = -droneVelocity.z * 5 + windEffect.x * 2;
            drone.rotation.z = droneVelocity.x * 5 + windEffect.z * 2;
            
            // Rota√ß√£o para seguir dire√ß√£o do movimento
            const targetRotation = Math.atan2(droneVelocity.x, droneVelocity.z);
            drone.rotation.y += (targetRotation - drone.rotation.y) * 0.08;

            // Atualizar h√©lices com efeito de blur
            propellers.forEach((propeller, index) => {
                const rotationSpeed = propeller.userData.rotationSpeed;
                const direction = propeller.userData.direction;
                
                propeller.rotation.y += rotationSpeed * direction;
                
                // Efeito de blur baseado na velocidade
                const blurOpacity = Math.min(speed * 50, 0.6);
                propeller.userData.blurEffect.material.opacity = blurOpacity;
                
                // Simular vibra√ß√£o dos motores
                propeller.position.y = 0.7 + Math.sin(time * 30 + index) * 0.005;
            });

            // Atualizar LEDs piscantes
            drone.children.forEach(child => {
                if (child.userData && child.userData.blinkTimer !== undefined) {
                    child.userData.blinkTimer += 0.1;
                    const intensity = 0.3 + Math.sin(child.userData.blinkTimer) * 0.7;
                    child.material.emissiveIntensity = intensity;
                }
            });

            // Atualizar sistema de escape dos motores
            updateDroneExhaust();

            // Manter gimbal da c√¢mera sempre apontando para baixo
            const gimbalGroup = drone.children.find(child => child.userData && child.userData.oscillation !== undefined);
            if (gimbalGroup) {
                gimbalGroup.userData.oscillation += 0.02;
                // Pequenas oscila√ß√µes naturais mas sempre apontando para baixo
                gimbalGroup.rotation.x = Math.sin(gimbalGroup.userData.oscillation) * 0.03;
                gimbalGroup.rotation.y = Math.cos(gimbalGroup.userData.oscillation * 0.5) * 0.02;
                gimbalGroup.rotation.z = 0; // Sem rota√ß√£o no eixo Z
            }

            // Manter o feixe sempre vertical
            if (scanBeam) {
                scanBeam.rotation.x = 0;
                scanBeam.rotation.y = 0;
                scanBeam.rotation.z = 0;
            }
        }

        function updateScanSystem() {
            const time = Date.now() * 0.001;
            
            // Pulsar o feixe de escaneamento com efeito mais cinematogr√°fico
            const pulseIntensity = 0.4 + Math.sin(time * 12) * 0.3 + Math.sin(time * 3) * 0.2;
            scanBeam.material.opacity = pulseIntensity;
            scanLight.intensity = 1.5 + pulseIntensity * 2;
            
            // Efeito de distor√ß√£o no feixe
            scanBeam.scale.x = 1 + Math.sin(time * 15) * 0.1;
            scanBeam.scale.z = 1 + Math.cos(time * 18) * 0.1;

            // Atualizar part√≠culas de escaneamento com f√≠sica avan√ßada
            scanParticles.forEach(particles => {
                const positions = particles.geometry.attributes.position.array;
                const colors = particles.geometry.attributes.color.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Movimento com turbul√™ncia
                    const turbulenceX = Math.sin(time * 8 + i * 0.1) * 0.02;
                    const turbulenceZ = Math.cos(time * 6 + i * 0.1) * 0.02;
                    
                    positions[i] += turbulenceX + (Math.random() - 0.5) * 0.05;
                    positions[i + 1] -= 0.4 + Math.random() * 0.3;
                    positions[i + 2] += turbulenceZ + (Math.random() - 0.5) * 0.05;
                    
                    // Reset com efeito de dispers√£o
                    if (positions[i + 1] < -22) {
                        const dispersal = 2 + Math.sin(time * 2) * 1;
                        positions[i + 1] = Math.random() * 2;
                        positions[i] = (Math.random() - 0.5) * dispersal;
                        positions[i + 2] = (Math.random() - 0.5) * dispersal;
                        scanPoints++;
                        
                        // Criar efeito de impacto com energia
                        createAdvancedScanImpact(
                            drone.position.x + positions[i],
                            drone.position.z + positions[i + 2]
                        );
                    }
                    
                    // Cores din√¢micas baseadas na profundidade
                    const depth = Math.abs(positions[i + 1]) / 20;
                    const pulseEffect = Math.sin(time * 10 + i * 0.5) * 0.3;
                    
                    colors[i] = 0.1 + depth * 0.2;  // R
                    colors[i + 1] = 0.7 + pulseEffect;  // G
                    colors[i + 2] = 0.3 + depth * 0.4 + pulseEffect * 0.2;  // B
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;
            });

            // Sistema de escaneamento inteligente
            if (Math.random() < 0.15 && scanPoints % 8 === 0) {
                createDataVisualization(drone.position.x, drone.position.z);
            }
        }

        function createAdvancedScanImpact(x, z) {
            // M√∫ltiplos an√©is de energia
            for (let ring = 0; ring < 3; ring++) {
                const impactGeometry = new THREE.RingGeometry(0.1 + ring * 0.3, 0.8 + ring * 0.4, 12);
                const impactMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 1 - ring * 0.3 }
                    },
                    vertexShader: `
                        uniform float time;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        void main() {
                            vec3 color = vec3(0.0, 1.0, 0.6);
                            float pulse = sin(time * 15.0) * 0.5 + 0.5;
                            gl_FragColor = vec4(color, opacity * pulse);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const impact = new THREE.Mesh(impactGeometry, impactMaterial);
                impact.position.set(x, 0.1 + ring * 0.05, z);
                impact.rotation.x = -Math.PI / 2;
                scene.add(impact);

                // Anima√ß√£o avan√ßada
                let animationTime = 0;
                const animate = () => {
                    animationTime += 0.05;
                    impact.material.uniforms.time.value = animationTime;
                    impact.scale.x = 1 + animationTime * 2;
                    impact.scale.y = 1 + animationTime * 2;
                    impact.material.uniforms.opacity.value = (1 - ring * 0.3) * (1 - animationTime / 3);
                    
                    if (animationTime < 3) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(impact);
                    }
                };
                
                setTimeout(() => animate(), ring * 100);
            }
        }

        function createDataVisualization(x, z) {
            // Visualiza√ß√£o de dados escaneados
            const dataGroup = new THREE.Group();
            
            // Hologramas de dados
            for (let i = 0; i < 5; i++) {
                const height = Math.random() * 3 + 1;
                const barGeometry = new THREE.BoxGeometry(0.2, height, 0.2);
                const barMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0x003300
                });
                
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                bar.position.set(
                    (i - 2) * 0.4,
                    height / 2,
                    0
                );
                dataGroup.add(bar);
            }
            
            dataGroup.position.set(
                x + (Math.random() - 0.5) * 5,
                0,
                z + (Math.random() - 0.5) * 5
            );
            
            scene.add(dataGroup);
            
            // Fade out ap√≥s alguns segundos
            setTimeout(() => {
                const fadeOut = () => {
                    dataGroup.children.forEach(child => {
                        child.material.opacity -= 0.02;
                    });
                    
                    if (dataGroup.children[0].material.opacity > 0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        scene.remove(dataGroup);
                    }
                };
                fadeOut();
            }, 3000);
        }

        function createScanImpact(x, z) {
            // Criar pequeno flash de luz no ponto de impacto
            const impactGeometry = new THREE.RingGeometry(0.1, 0.5, 8);
            const impactMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide
            });
            const impact = new THREE.Mesh(impactGeometry, impactMaterial);
            impact.position.set(x, 0.1, z);
            impact.rotation.x = -Math.PI / 2;
            scene.add(impact);

            // Animar o fade out
            const fadeAnimation = () => {
                impact.material.opacity -= 0.05;
                if (impact.material.opacity <= 0) {
                    scene.remove(impact);
                } else {
                    requestAnimationFrame(fadeAnimation);
                }
            };
            fadeAnimation();
        }

        function createScanPoint(x, z) {
            // Criar ponto de dados escaneados
            const pointGeometry = new THREE.SphereGeometry(0.2);
            const pointMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                emissive: 0x003300,
                transparent: true,
                opacity: 0.8
            });
            const scanPoint = new THREE.Mesh(pointGeometry, pointMaterial);
            scanPoint.position.set(
                x + (Math.random() - 0.5) * 10,
                0.2,
                z + (Math.random() - 0.5) * 10
            );
            scene.add(scanPoint);

            // Remover ap√≥s alguns segundos
            setTimeout(() => {
                if (scene.children.includes(scanPoint)) {
                    scene.remove(scanPoint);
                }
            }, 5000);
        }

        function updateUI() {
            document.getElementById('altitude').textContent = drone.position.y.toFixed(1) + 'm';
            
            // Calcular velocidade real baseada na velocidade do drone
            const realSpeed = Math.sqrt(droneVelocity.x * droneVelocity.x + droneVelocity.z * droneVelocity.z) * 100;
            document.getElementById('speed').textContent = Math.max(0.1, realSpeed).toFixed(1) + ' m/s';
            
            document.getElementById('battery').textContent = Math.max(20, 100 - Math.floor(scanPoints / 100)).toString() + '%';
            document.getElementById('scanPoints').textContent = scanPoints.toString();
        }

        // Fun√ß√µes de controle
        function toggleAnimation() {
            animationRunning = !animationRunning;
        }

        function updateAnimatedTextures(time) {
            // Atualizar textura do terreno se usar shader
            if (terrain && terrain.material.uniforms) {
                terrain.material.uniforms.time.value = time;
            }
            
            // Animar texturas de √°gua
            if (textureLibrary.water) {
                textureLibrary.water.offset.x = Math.sin(time * 0.5) * 0.1;
                textureLibrary.water.offset.y = Math.cos(time * 0.3) * 0.1;
            }
            
            // Animar texturas de folhas (efeito de vento)
            if (textureLibrary.leaves) {
                textureLibrary.leaves.offset.x = Math.sin(time * 0.8) * 0.02;
                textureLibrary.leaves.offset.y = Math.cos(time * 0.6) * 0.02;
            }
            
            // Animar texturas de grama
            if (textureLibrary.grass) {
                textureLibrary.grass.offset.x = Math.sin(time * 0.2) * 0.005;
                textureLibrary.grass.offset.y = Math.cos(time * 0.15) * 0.005;
            }
        }

        function updateEnvironment() {
            if (!scene) return;
            
            const time = Date.now() * 0.001;
            
            // Atualizar skybox din√¢mico
            if (skybox && skybox.userData && skybox.userData.isSkybox && skybox.material.uniforms) {
                skybox.material.uniforms.time.value = time;
            }
            
            // Atualizar texturas animadas
            updateAnimatedTextures(time);
            
            // Animar nuvens volum√©tricas
            if (cloudSystem) {
                cloudSystem.children.forEach(cloud => {
                    cloud.position.x += cloud.userData.speed * Math.sin(time * 0.1);
                    cloud.position.y = cloud.userData.originalY + Math.sin(time * 0.2 + cloud.position.x * 0.01) * 5;
                    cloud.rotation.y += 0.001;
                });
            }
            
            // Animar part√≠culas atmosf√©ricas
            if (atmosphericParticles) {
                const positions = atmosphericParticles.geometry.attributes.position.array;
                const velocities = atmosphericParticles.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];
                    
                    // Reset part√≠culas que sa√≠ram da √°rea
                    if (positions[i + 1] < 0) {
                        positions[i] = (Math.random() - 0.5) * 400;
                        positions[i + 1] = 100;
                        positions[i + 2] = (Math.random() - 0.5) * 400;
                    }
                }
                atmosphericParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animar √°gua com reflexos realistas
            rivers.concat(lakes).forEach((water, index) => {
                if (water.material) {
                    water.material.opacity = 0.8 + Math.sin(time * 1.5 + index) * 0.15;
                    // Simular ondula√ß√µes
                    if (water.geometry.attributes.position) {
                        const positions = water.geometry.attributes.position.array;
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] = Math.sin(time * 3 + positions[i - 1] * 0.1) * 0.1;
                        }
                        water.geometry.attributes.position.needsUpdate = true;
                    }
                }
            });

            // P√°ssaros com voo mais realista
            scene.children.forEach(child => {
                if (child.userData && child.userData.speed && child.userData.wingBeat !== undefined) {
                    // Movimento de voo
                    child.userData.angle += child.userData.speed * 0.015;
                    child.position.x += Math.cos(child.userData.angle) * child.userData.speed;
                    child.position.z += Math.sin(child.userData.angle) * child.userData.speed;
                    child.position.y = child.userData.height + Math.sin(time * 2 + child.userData.angle) * 3;
                    
                    // Anima√ß√£o das asas
                    child.userData.wingBeat += 0.3;
                    child.children.forEach(part => {
                        if (part.userData && part.userData.isWing) {
                            const wingAngle = Math.sin(child.userData.wingBeat) * 0.8;
                            part.rotation.z = part.userData.side === 0 ? wingAngle : -wingAngle;
                        }
                    });
                    
                    // Orienta√ß√£o do p√°ssaro
                    child.rotation.y = child.userData.angle;
                    child.rotation.z = Math.sin(child.userData.wingBeat) * 0.1;
                    
                    // Reset posi√ß√£o
                    if (Math.abs(child.position.x) > 250 || Math.abs(child.position.z) > 250) {
                        child.position.x = (Math.random() - 0.5) * 100;
                        child.position.z = (Math.random() - 0.5) * 100;
                    }
                }
            });

            // Movimento realista das √°rvores
            forests.forEach(tree => {
                if (tree.children.length > 1) {
                    tree.children.forEach((part, index) => {
                        if (index > 0) {
                            const windStrength = 0.03 + Math.sin(time * 0.5) * 0.02;
                            part.rotation.x = Math.sin(time * 0.8 + tree.position.x * 0.05) * windStrength;
                            part.rotation.z = Math.cos(time * 0.6 + tree.position.z * 0.05) * windStrength;
                        }
                    });
                }
            });

            // Chamas da fogueira mais realistas
            scene.children.forEach(child => {
                if (child.userData && child.userData.isFlame) {
                    child.scale.x = 1 + Math.sin(time * 12) * 0.4;
                    child.scale.z = 1 + Math.cos(time * 8) * 0.4;
                    child.scale.y = 1 + Math.sin(time * 15) * 0.3;
                    child.rotation.y += 0.02;
                }
            });

            // N√©voa din√¢mica
            scene.children.forEach(child => {
                if (child.userData && child.userData.drift !== undefined) {
                    child.position.x += Math.sin(time * child.userData.drift) * 0.1;
                    child.position.z += Math.cos(time * child.userData.drift) * 0.1;
                    child.material.opacity = child.userData.originalOpacity + 
                                           Math.sin(time * 2) * 0.05;
                }
            });

            // Folhas caindo
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'leaves') {
                    const positions = child.geometry.attributes.position.array;
                    const velocities = child.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i] + Math.sin(time + i) * 0.001;
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2] + Math.cos(time + i) * 0.001;
                        
                        // Reset folhas que chegaram ao ch√£o
                        if (positions[i + 1] < 0) {
                            positions[i] = (Math.random() - 0.5) * 300;
                            positions[i + 1] = 50 + Math.random() * 20;
                            positions[i + 2] = (Math.random() - 0.5) * 300;
                        }
                    }
                    child.geometry.attributes.position.needsUpdate = true;
                }
            });

        }

        function resetDrone() {
            droneAngle = 0;
            scanRadius = 30;
            scanPoints = 0;
            drone.position.set(0, 25, 0);
            droneVelocity = { x: 0, y: 0, z: 0 };
            droneAcceleration = { x: 0, y: 0, z: 0 };
            drone.rotation.set(0, 0, 0);
        }

        function changeScanMode() {
            scanMode = scanMode >= 3 ? 1 : scanMode + 1;
            const modes = ['', 'Circular', 'Espiral', 'Grid'];
            console.log('Modo de escaneamento:', modes[scanMode]);
        }

        // Responsividade
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inicializar quando a p√°gina carregar
        init();
    </script>
</body>
</html> 